# ADR-0002: CQRS with Event Sourcing Implementation

**Status**: ðŸŸ¢ Accepted  
**Date**: 2025-01-18  
**Deciders**: Development Team  
**Supersedes**: ADR-0003 (CQRS Event Sourcing), ADR-0004 (Amplify Gen2 Query Model)

## Context and Problem Statement

We need to implement a data architecture that:
- Supports complex business logic with complete audit trails
- Provides optimized read and write models for different use cases
- Enables temporal queries and system state reconstruction
- Scales independently for read and write operations
- Supports real-time updates to frontend applications
- Integrates seamlessly with our event-driven architecture

## Decision Drivers

* Need for complete audit trail of all system changes
* Requirement for complex business logic separation
* High read/write performance requirements
* Support for event replay and system recovery
* Real-time updates in the frontend via subscriptions
* Type safety between frontend and backend
* Regulatory compliance and audit requirements
* Need for optimized read models vs write models

## Considered Options

### Data Architecture Options
* Traditional CRUD with single database model
* CQRS without event sourcing
* CQRS with event sourcing using DynamoDB
* CQRS with event sourcing using purpose-built event store
* Event sourcing only (no CQRS separation)

### Query Model Options
* Manual GraphQL API with Apollo Server on Lambda
* AWS AppSync with manual schema definition
* Amplify Gen2 with auto-generated GraphQL API
* REST APIs with manual caching for read models
* Hasura with PostgreSQL for GraphQL

## Decision Outcome

Chosen options:
1. **CQRS with event sourcing using DynamoDB** for data architecture
2. **Amplify Gen2 with auto-generated GraphQL API** for query models

This combination provides complete audit trails, excellent scalability, real-time updates, and rapid development while leveraging AWS managed services.

### Implementation Details

**CQRS Architecture Overview**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Frontend                              â”‚
â”‚                    (React + Amplify)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ Commands              â”‚ Queries/Subscriptions
              â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Gateway (REST)    â”‚  â”‚   AppSync (GraphQL)            â”‚
â”‚   Command Endpoints     â”‚  â”‚   Auto-generated by Amplify    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                              â”‚
            â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Step Functions        â”‚  â”‚   DynamoDB Read Models         â”‚
â”‚   Command Processing    â”‚  â”‚   (Managed by Amplify)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                              â–²
            â–¼                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  DynamoDB Event Store   â”‚                â”‚
â”‚  (Immutable Events)     â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
            â”‚                              â”‚
            â–¼                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     EventBridge         â”‚  â”‚   Lambda Functions             â”‚
â”‚   Event Publication     â”‚â”€â”€â–ºâ”‚   Read Model Projections       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Event Store Implementation**:

**DynamoDB Schema**:
```yaml
EventStore:
  Type: AWS::DynamoDB::Table
  Properties:
    TableName: !Sub 'skafu-events-${Environment}'
    AttributeDefinitions:
      - AttributeName: aggregateId
        AttributeType: S
      - AttributeName: eventSequence
        AttributeType: N
    KeySchema:
      - AttributeName: aggregateId
        KeyType: HASH
      - AttributeName: eventSequence
        KeyType: RANGE
    StreamSpecification:
      StreamViewType: NEW_AND_OLD_IMAGES
```

**Event Structure**:
```python
@dataclass
class Event:
    eventId: str          # UUID
    eventType: str        # e.g., "ProjectCreated"
    aggregateId: str      # ID of the aggregate
    eventSequence: int    # Sequence number for ordering
    eventData: Dict       # Business data
    correlationId: str    # For distributed tracing
    timestamp: str        # ISO-8601 timestamp
    version: str          # Event schema version
    metadata: Dict        # Additional context
```

**Amplify Gen2 Query Model**:

**Schema Definition**:
```typescript
// amplify/data/resource.ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // Project read model
  Project: a.model({
    id: a.id(),
    name: a.string().required(),
    description: a.string(),
    status: a.enum(['ACTIVE', 'ARCHIVED', 'DELETED']),
    services: a.hasMany('Service', 'projectId'),
    createdAt: a.datetime(),
    updatedAt: a.datetime(),
    owner: a.string()
  })
  .authorization([
    a.allow.owner(),
    a.allow.groups(['Admin']),
    a.allow.groups(['Developer']).to(['read'])
  ]),

  // Service read model
  Service: a.model({
    id: a.id(),
    projectId: a.id().required(),
    name: a.string().required(),
    type: a.enum(['API', 'FRONTEND', 'WORKER']),
    configuration: a.json(),
    project: a.belongsTo('Project', 'projectId')
  }),

  // Metric read model (for observability)
  Metric: a.model({
    id: a.id(),
    name: a.string().required(),
    value: a.float().required(),
    unit: a.string().required(),
    tags: a.json(),
    timestamp: a.datetime().required(),
    source: a.string().required()
  })
  .secondaryIndexes((index) => [
    index('name').sortKeys(['timestamp']).queryField('listMetricsByName'),
    index('source').sortKeys(['timestamp']).queryField('listMetricsBySource')
  ])
});

export type Schema = ClientSchema<typeof schema>;
export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'userPool',
    apiKeyAuthorizationMode: { expiresInDays: 30 }
  }
});
```

**Command Processing Pattern**:

```python
# Lambda handler for command processing
class ProjectCommandHandler:
    def __init__(self):
        self.event_store = EventStore()
        self.repository = ProjectRepository(self.event_store)
    
    def create_project(self, command: CreateProjectCommand) -> str:
        # Load aggregate (creates new if not exists)
        project = self.repository.get(command.project_id) or ProjectAggregate(id=command.project_id)
        
        # Execute business logic
        project.create(
            name=command.name,
            description=command.description,
            owner=command.owner
        )
        
        # Save events to event store
        self.repository.save(project)
        
        # Publish events to EventBridge
        for event in project.uncommitted_events:
            self.event_publisher.publish(event)
        
        return project.id
```

**Read Model Projection**:

```python
# Lambda function triggered by EventBridge
def project_projection_handler(event, context):
    # Parse domain event
    domain_event = parse_event(event)
    
    # Update read model based on event type
    if domain_event.event_type == "ProjectCreated":
        # Create project in Amplify-managed DynamoDB table
        create_project_read_model(domain_event.event_data)
        
        # Trigger AppSync subscription
        notify_subscribers('projectCreated', domain_event.event_data)
    
    elif domain_event.event_type == "ServiceAdded":
        # Update project with new service
        add_service_to_project(domain_event.event_data)
        
        # Trigger AppSync subscription
        notify_subscribers('projectUpdated', domain_event.event_data)
```

**Frontend Integration**:

```typescript
// React component using Amplify Data
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource';

const client = generateClient<Schema>();

function ProjectList() {
  const [projects, setProjects] = useState<Schema['Project'][]>([]);
  
  useEffect(() => {
    // Query projects
    const fetchProjects = async () => {
      const { data } = await client.models.Project.list();
      setProjects(data);
    };
    
    fetchProjects();
    
    // Subscribe to real-time updates
    const subscription = client.models.Project.onCreate().subscribe({
      next: (project) => {
        setProjects(prev => [...prev, project]);
      }
    });
    
    return () => subscription.unsubscribe();
  }, []);
  
  return (
    <div>
      {projects.map(project => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </div>
  );
}
```

### Data Flow Patterns

**Command Flow**:
1. Frontend sends command via API Gateway REST endpoint
2. Step Function validates and processes command
3. Step Function stores event in DynamoDB event store
4. Step Function publishes event to EventBridge
5. Event consumers update read models and trigger subscriptions

**Query Flow**:
1. Frontend queries via Amplify-generated GraphQL API
2. AppSync resolves from optimized DynamoDB read models
3. Real-time updates delivered via GraphQL subscriptions
4. Type-safe data with auto-generated TypeScript types

**Event Replay Flow**:
1. Identify events to replay by aggregate or time range
2. Read events from event store in sequence
3. Republish events to EventBridge with replay marker
4. Projections rebuild read models from replayed events

### Domain Aggregate Examples

**Project Aggregate**:
```python
class ProjectAggregate(AggregateRoot):
    def create(self, name: str, description: str, owner: str):
        self.raise_event("ProjectCreated", {
            "projectId": self.id,
            "name": name,
            "description": description,
            "owner": owner
        })
    
    def add_service(self, service_name: str, service_type: str):
        self.raise_event("ServiceAdded", {
            "projectId": self.id,
            "serviceName": service_name,
            "serviceType": service_type
        })
    
    def _apply_event(self, event: Event):
        if event.event_type == "ProjectCreated":
            self.name = event.event_data["name"]
            self.description = event.event_data["description"]
            self.owner = event.event_data["owner"]
            self.services = []
        elif event.event_type == "ServiceAdded":
            self.services.append({
                "name": event.event_data["serviceName"],
                "type": event.event_data["serviceType"]
            })
```

### Consequences

**Good**:
* **Complete audit trail**: Every state change is preserved forever
* **Temporal queries**: Can reconstruct state at any point in time
* **Scalability**: Independent scaling of read and write operations
* **Performance**: Optimized read models for specific query patterns
* **Recovery**: System state can be rebuilt from events
* **Real-time updates**: Automatic UI updates via GraphQL subscriptions
* **Type safety**: Auto-generated types ensure frontend-backend consistency
* **Rapid development**: Amplify Gen2 eliminates boilerplate code
* **Compliance**: Immutable audit log meets regulatory requirements

**Bad**:
* **Complexity**: Higher conceptual and implementation complexity
* **Eventually consistent**: Read models may lag behind events
* **Storage overhead**: Events and read models require more storage
* **Event versioning**: Schema evolution requires careful planning
* **Learning curve**: Team needs to understand CQRS and event sourcing
* **Debugging complexity**: Distributed state reconstruction for debugging
* **Query limitations**: Some queries may require multiple read models

## Implementation Guidelines

1. **Aggregate Design**: Design aggregates around business consistency boundaries
2. **Event Naming**: Use past-tense, business-meaningful event names
3. **Event Immutability**: Events are append-only, never updated or deleted
4. **Projection Design**: Create read models optimized for specific UI needs
5. **Error Recovery**: Design for replay and recovery scenarios
6. **Schema Evolution**: Plan for backward-compatible event changes
7. **Testing Strategy**: Test commands, events, and projections separately

## More Information

* [CQRS Pattern Documentation](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)
* [Event Sourcing Pattern](https://martinfowler.com/eaaDev/EventSourcing.html)
* [AWS Amplify Gen2 Documentation](https://docs.amplify.aws/gen2/)
* [DynamoDB Best Practices](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
* Related ADRs: ADR-0001 (Core Architecture), ADR-0003 (Observability)